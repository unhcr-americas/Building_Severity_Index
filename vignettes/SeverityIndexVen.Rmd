---
title: " Review of Protection Severity Index"
date: " `r format(Sys.Date(),  '%d %B %Y')`"
always_allow_html: yes
output:
  html_document:
    toc: true
params:
  file: "SeverityVenezuela"
  country: "Venezuela"
  geojson: "VenLevel1.geojson"
author: "`r params$country`"
---

<!--
2.1 All packages used are loaded upfront so the reader knows which are required to replicate the analysis. 
2.2 Messages and warnings resulting from loading the package are suppressed. 
2.3 Explanation is provided regarding the purpose of each package (there are over 10,000 packages, don't assume that I know why you loaded each package).
-->

```{r setup, message=FALSE, warning=FALSE,  echo=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	fig.width = 9,
	fig.asp = 0.8,
	message = TRUE,
	warning = FALSE,
	collapse = FALSE,
	comment = " "
) 
set.seed(1)
extrafont::loadfonts(quiet=TRUE)
options(scipen = 999) # turn-off scientific notation like 1e+48
library(unhcRstyle)
library(COINr)
library(dplyr)
library(reactable)
library(magrittr)
# devtools::install_github("vqv/ggbiplot")
library(ggbiplot)
library(geojsonio)
```

# Stage 0:  Load & Assemble data

```{r}
geo <-  geojsonio::geojson_read(here::here("data-raw",params$geo),  what = "sp")
geo@data$UnitCode <- geo@data$ADM1_PCODE 
```

```{r}
file <- paste0(params$file,".xlsx")
SeverityIndex <- COINr::assemble(
  IndData = readxl::read_excel(here::here("data-raw",file), sheet = "IndData"),
  IndMeta = readxl::read_excel(here::here("data-raw",file), sheet = "IndMeta"),
  AggMeta = readxl::read_excel(here::here("data-raw",file), sheet = "AggMeta")
  )
``` 

# Stage 1. Review & Process data

  1. Indicator statistics 
  
  2. Denominator
  
  3. Outliers
  
  4. Normalisation
  
  5. Aggregation


## Indicator statistics 

```{r }
# We can change thresholds for flagging outliers and high/low correlations.
SeverityIndex <- COINr::getStats(SeverityIndex, dset = "Raw")
# view stats within a table
stat <- SeverityIndex$Analysis$Raw$StatTable

stat %>%
  roundDF() %>%
  #head( 6) %>%
  select(Indicator, Skew, Kurtosis, Prc.complete, SK.outlier.flag  ) %>%
  reactable()
```


## Denominator

```{r }
# create denominated data set
SeverityIndex <- COINr::denominate(SeverityIndex, dset = "Raw")

# get stats of denominated data
SeverityIndex <- COINr::getStats(SeverityIndex, dset = "Denominated")

# view stats table
denom <- SeverityIndex$Analysis$Raw$StatTable
denom  %>%  
  reactable()
``` 


## Outliers

```{r Treat}
SeverityIndex <- COINr::treat(SeverityIndex, 
              dset = "Denominated", 
              winmax = 5)
# View(SeverityIndex$Data$Raw)
# View(SeverityIndex$Data$Denominated)
treat <- SeverityIndex$Analysis$Treated$TreatSummary 
treat %>%
  filter(Treatment != "None") %>% 
 # head( 5) %>%
  reactable()
```



```{r Winsorisation}
COINr::iplotIndDist2(SeverityIndex, 
              dsets = c("Denominated", "Treated"), 
              icodes = "Proteccion", 
              ptype = "Scatter")
``` 

## Normalisation

```{r}
SeverityIndex <- COINr::normalise(SeverityIndex, 
                  dset = "Treated", 
                  ntype = "minmax", 
                  npara = list(minmax = c(1,100)))
```

## Aggregation

```{r}
SeverityIndex <- COINr::aggregate(SeverityIndex, 
                  agtype = "geom_mean", 
                  dset = "Normalised")
```


We have now complete the construction of the COIN object with each of the following data stage: `r names(SeverityIndex$Data)`

```{r}
# check data set names
#names(SeverityIndex$Data)
# View(SeverityIndex$Data$Raw)
# View(SeverityIndex$Data$Denominated)
# View(SeverityIndex$Data$Aggregated)
## Check with ShinyApp
# COINr::resultsDash(SeverityIndex, dset = "Aggregated")
# COINr::rew8r(SeverityIndex)
``` 



# Stage 2. Question the  assumptions


  1. Correlations between indicators,  with parents pillars,  within and between pillars
  
  2. Internal Consistency
  
  3. Principle component
  
  4. Effect of specific formulation
  
  5. Sensitivity Analysis


## Internal Consistency

Cronbachâ€™s alpha, (or coefficient alpha), developed by Lee Cronbach in 1951, measures reliability (i.e. how well a test measures what it should: measure of the stability of test scores), or internal consistency.
 
```{r }

# all indicators
cronbach <- getCronbach(SeverityIndex, dset = "Aggregated") 
if(cronbach >= 0.6 ) {
  cat(paste0("The Cronbach Alpha measure of consistency for all indicators is ", round(cronbach, 2), ", which suggests that all indicators are highly correlated (meaning also potentially that indicators might be redundant...).\n\n" ) )
} else {
  cat(paste0("The Cronbach Alpha measure of consistency for all indicators is ", round(cronbach, 2), ", which  suggests  which that there are not enough indicators for the construct or that the selected indicators are poorly interrelated.\n\n" ) )}
 
Aggg <- as.data.frame(SeverityIndex$Input$AggMeta)
for( i in 1:nrow(Aggg))
{
IndCompCode <- as.character(Aggg[ i, c("Code")])
IndCompLab <- as.character(Aggg[ i, c("Name")])
IndCompLev <- as.integer(Aggg[ i, c("AgLevel")]) -1

cronbach <- getCronbach(SeverityIndex, 
                        dset = "Aggregated", 
                        icodes = IndCompCode, 
                        aglev = IndCompLev) 
if(cronbach >= 0.6 ) {
  cat(paste0("The Cronbach Alpha measure of consistency for indicators related to \"",IndCompLab, "\" is ", round(cronbach, 2), ", which suggests that all indicators are highly correlated (meaning also potentially that indicators might be redundant...).\n\n" ) )
} else {
  cat(paste0("The Cronbach Alpha measure of consistency for indicators related to \"",IndCompLab, "\" is ", round(cronbach, 2), ", which suggests  which that there are not enough indicators for the construct or that the selected indicators are poorly interrelated.\n\n" ) )}
}


```

## Correlation

```{r}
COINr::plotCorr(SeverityIndex, 
                dset = "Aggregated", 
                showvals = T, 
                withparent = "family", 
                flagcolours = TRUE)
```


```{r }

for( i in 1:nrow(Aggg))
{
  # i <- 6
  # bY Component 
IndCompCode <- as.character(Aggg[ i, c("Code")])
IndCompLab <- as.character(Aggg[ i, c("Name")])
IndCompLev <- as.integer(Aggg[ i, c("AgLevel")]) -1

print(COINr::plotCorr(SeverityIndex, 
                      dset = "Aggregated", 
                icodes = IndCompCode, 
                aglevs = IndCompLev, 
                cortype = "spearman",
                pval = 0))
}


``` 



## Principle component

```{r }
# impute one
# SeverityIndex2 <- impute(SeverityIndex, dset = "Denominated", 
#                 imtype = "indgroup_mean", 
#                 groupvar = "Group_Region")
# SeverityIndex2 <- normalise(SeverityIndex2, dset = "Treated", 
#                    ntype = "minmax", 
#                    npara = list(minmax = c(0,100)))
# try here at the indicator level, let's say within one of the pillar groups:
PCA_P2P <- getPCA(SeverityIndex, dset = "Normalised", 
                  icodes = "Proteccion", 
                  aglev = 1, 
                  out2 = "list")

summary(PCA_P2P$PCAresults$P2P$PCAres)
```

## Effect of specific formulation

```{r }
#  `effectiveWeight()` gives effective weights for all levels. We can check the indicator level by filtering:
EffWts <- effectiveWeight(SeverityIndex)
COINr::plotframework(SeverityIndex)


```

## Uncertainty Analysis

```{r}
# define noise to be applied to weights
nspecs <- data.frame(AgLevel = c(2,3), 
                     NoiseFactor = c(0.25,0.25))

# create list specifying assumptions to vary and alternatives
SAspecs <- list(
 # impute = list(imtype = c("indgroup_mean", "ind_mean", "none")),
  normalise = list(ntype = c("minmax",
                             "rank",
                             "dist2max")),
  weights = list(NoiseSpecs = nspecs, 
                 Nominal = "Original")
)

```

```{r}
# run uncertainty analysis
UAresults <- COINr::sensitivity(SeverityIndex, 
                # The target variable to perform analysis on. 
                # Currently just supports one variable, which should be an 
                # indicator/aggregate code present in .$Data$Aggregated.
                         v_targ = "Index",
               # A list which specifies which variables to perturb, and which alternatives/distributions to use
                         SA_specs = SAspecs,
               # number of Monte Carlo replications.
                         N = 10,
               # type of analysis to run. "UA" runs an uncertainty analysis. 
               # "SA" runs a sensitivity analysis (which anyway includes an uncertainty analysis)
                         SA_type = "UA")

# see summary of analysis
#summary(SAresults)

# data frame gives the uncertain parameter values used for each iteration:
#SAresults$Parameters 

# summary of the main statistics of the ranks of each unit, including mean, median, and percentiles:
# SAresults$RankStats

COINr::plotSARanks(UAresults)
```

## Sensitivity Analysis

```{r}
# run uncertainty analysis
SAresults <- COINr::sensitivity(SeverityIndex,
                # The target variable to perform analysis on. 
                # Currently just supports one variable, which should be an 
                # indicator/aggregate code present in .$Data$Aggregated.
                         v_targ = "Index",
               # A list which specifies which variables to perturb, and which alternatives/distributions to use
                         SA_specs = SAspecs,
               # number of Monte Carlo replications.
                         N = 10,
               # type of analysis to run. "UA" runs an uncertainty analysis. 
               # "SA" runs a sensitivity analysis (which anyway includes an uncertainty analysis)
                         SA_type = "SA",
               # Number of bootstrap draws for estimates of confidence intervals on sensitivity indices. 
               # If this is not specified, bootstrapping is not applied. 
                         Nboot = 1000)

# plot shows the three uncertainties that we introduced on the x-axis: the imputation type, the normalisation type, and the weights. 
# The y-axis is the sensitivity index, and the total height of each bar is the total effect index STi, i.e. the uncertainty caused by the variable on its own (the main effect) as well as its interactions. 
# Then each bar is divided into the interaction effects and the main effects.
COINr::plotSA(SAresults, ptype = "pie")
```


# Stage 3. Visualize Results

  1. Index & Sub Dimensions
  
  2. Interactions between dimension
  
  3. Ranking

## Present summary table.

```{r }
COINr::getResults(SeverityIndex, 
                  tab_type = "Summary") %>%
 # head(7)%>%
  knitr::kable()

# Write full results table to COIN
COINr::getResults(SeverityIndex, tab_type = "FullWithDenoms", out2 = "COIN")

# Export entire COIN to Excel
COINr::coin2Excel(SeverityIndex, here::here("data-raw", paste0(params$file,"_results.xlsx"))  )
```


## Index & Sub Dimensions

```{r  }
options(htmltools.dir.version = FALSE, 
        htmltools.preserve.raw = FALSE,
        tibble.width = 60)
COINr::iplotBar(SeverityIndex, 
                dset = "Aggregated", # The data set to plot.
                isel = "Index", # The selected indicator code or aggregate (does not support multiple indicators)
                aglev = 3, # The aggregation level to collect the indicator data from (this needs to be specified)
                stack_children = T) # If TRUE, produces a stacked bar chart with any children of isel. In this case, usel is ignored. This only works if dset = "Aggregated" and aglev > 1.
```


## Sub Indices Interactions


```{r  }
options(htmltools.dir.version = FALSE, 
        htmltools.preserve.raw = FALSE,
        tibble.width = 60)
COINr::iplotIndDist2(SeverityIndex, 
              dsets = "Aggregated", 
              icodes = "Index")
```

## Map


```{r mapsftheme, echo = FALSE, message = FALSE, warning = FALSE, cache =TRUE}
##Set up the theme for all maps below! 

## Sea #B3D8F0
## Name #828993
## Border #93A3AB
## Country #E2E7EB
## Feature country #FFFFFF
##

# Select a font already installed on your system !!
par(family="Lato")
# set a theme
mapsf::mf_theme(bg = "#E2E7EB",  ## background color --> Used country 
                # bg = "#cdd2d4", "#faebd7ff",  "#cdd2d4",
                mar = c(0, 0, 2, 0), ## margins
                tab = FALSE,  # if TRUE the title is displayed as a 'tab'
                fg = "#0072BC",  ## foreground color --> for the top title - use UNHCR Blue..
                pos = "left", # position, one of 'left', 'center', 'right'
                inner = FALSE, # if TRUE the title is displayed inside the plot area.
                line = 2, #number of lines used for the title
                cex = 1.5, #cex of the title
                #font = "Lato",
                font = 1 ) #font of the title




```


```{r, message=FALSE, warning=FALSE, fig.height= 10, fig.width= 10}

SeverityIndex$Data$Aggregated$Index_quint <- Hmisc::cut2(SeverityIndex$Data$Aggregated$Index, g = 5) 
geo2 <- dplyr::left_join(x = sf::st_as_sf(geo), y = SeverityIndex$Data$Aggregated, by=c("UnitCode") )
## Color scale - https://developer.r-project.org/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/

mapsf::mf_init(geo2) 
mapsf::mf_map(geo2, 
              add = TRUE, 
              lwd = 0.5, 
              border = "#93A3AB", 
              col = "#FFFFFF") 

mapsf::mf_prop_typo( 
  x = geo2, 
  var = c("x_TotPop", "Index_quint"),
  inches = .05, 
  border = "tomato4",
  alpha = .8,
  val_max = 90000, 
  symbol = "circle", 
  col_na = "grey", 
  pal = "Inferno",
  lwd = 1,
  leg_pos = c("bottomright", "bottomleft"),
  leg_title = c("Population", "Severity Index"),
  leg_title_cex = c(0.9, 0.9),
  leg_val_cex = c(.7, .7),
   leg_no_data = "No dada",
   leg_frame = c(TRUE, TRUE),
  add = TRUE
)

# Set a layout
mapsf::mf_title(txt = "Severity Index (Geometric Aggregation of Normalised Indicators)", 
                fg = "#FFFFFF")
mapsf::mf_credits(txt = "Source: Multiple Indicators aggregated at level 2",
                   bg = "#ffffff80") 


```




```{r, message=FALSE, warning=FALSE, fig.height= 10, fig.width= 10}

## Color scale - https://developer.r-project.org/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/

mapsf::mf_init(geo2) 
mapsf::mf_map(geo2, 
              add = TRUE, 
              lwd = 0.5, 
              border = "#93A3AB", 
              col = "#FFFFFF") 

mapsf::mf_prop_typo( 
  x = geo2, 
  var = c("x_TotPop", "x_Overarching_scale"),
  inches = .05, 
  border = "tomato4",
  alpha = .8,
  val_max = 90000, 
  symbol = "circle", 
  col_na = "grey", 
  pal = "Inferno",
  lwd = 1,
  leg_pos = c("bottomright", "bottomleft"),
  leg_title = c("Population", "Severity Index"),
  leg_title_cex = c(0.9, 0.9),
  leg_val_cex = c(.7, .7),
   leg_no_data = "No dada",
   leg_frame = c(TRUE, TRUE),
  add = TRUE
)

# Set a layout
mapsf::mf_title(txt = "Severity Index (Arithmetic Aggregation of discretised Indicator)", 
                fg = "#FFFFFF")
mapsf::mf_credits(txt = "Source: Multiple Indicators aggregated at level 2",
                   bg = "#ffffff80") 


```


  
